# 科协第三次Task
##                                        ——刁彦卓
### 编程实现3
```c
//逆序输出整数
#include <stdio.h>
int main(void)
{
	long long a;
	scanf("%lld",&a);
	while(a!=0)
	{
    	printf("%lld",a%10);
    	a/=10;
	}
	return 0;
}
```

### 编程实现4
```c
#include <stdio.h>
int main(void)
{
    char arr[10000];
    int num[10000];
    char ch;
    int k=0,s,m=0,i=0,x=0;
    while((ch=getchar())!=EOF)
    {
            arr[i]=ch;
            i++;
    }
    for(int j=0;j<=i;j++)
    {
        if(arr[j]>='0'&&arr[j]<='9')
        {
            x=10*m+(arr[j]-'0');
            m=x;
            x=0;
        }
        else
        {
            if(m!=0)
            {
                num[k]=m;
                k++;
                m=0;
            }
        }
    }
    for(s=0;s<k;s++)
        printf("%d\n",num[s]);
    return 0;
}
```

### 编程实现5



## 提高任务
### 程序一
`*c[]`是指针数组，`**cp[]`是指针，`***cpp`是指针`cp`的指针。
看第一个`print`，`++cpp`说明指针加一，此时纸箱的是`cp`中的第二个元素即`c+2`。之后对`cpp`二次取值，第一次取值结果是`c+2`,此时指向`c`中的第三个元素`POINT`，再一次取值得`POINT`,最后输出结果`POINT`.

第二个`print`,`*--*++cpp + 3`,先算`++cpp`为`cp+2`,取值为`c+1`,再自减为`c`,取值为`ENTER`,再+3，因此输出`ER`.
第三个`print`,`*cpp[-2] + 3`,`cpp[-2]`为再当前所指位置上往前退两个单位，因此为`c+3`,取值为`FIRST`,再+3，最后输出`ST`.
第四个`print`,`cpp[-1][-1] + 3`,先后面[-1]，变为`(c+2)[-1]`,再前面[-1],变为`NEW`,再+1，最后输出结果为`EW`.

### 程序二
根据结构体的内存占用空间大小的计算方法，该结构体所占空间为4×8=32字节，即p占32字节。
第一行`p + 0x1`,为p+p所占空间的大小×数字，32转化为16进制数为20，所以结果为`100020`
第二行强制类型转换为`unsigned long`型，占八个字节，按照前后两个的算法应该是100000+1×8=100008,但结果是100001，不明白。
第三行强制类型转换为`unsigned int*`型，占四个字节，所以结果是100000+1×4字节=100004

### 程序三
（有点迷糊）
第一行，`&a+1`是指针加法，不是普通的数值加法。指针加法大大小取决于a的类型。如果a为int型的数组，则`&a+1`的值为`a的地址+4×数组元素`，所以`&a+1`就等于`a+4`,指向数组最后一个元素的下一位，再[-1]，即指向4，所以输出为`4`.
第二行，不是很明白为什么最后输出了那几个0.求解。。。